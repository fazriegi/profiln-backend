// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package homepage

import (
	"context"
	"database/sql"
)

const getUserById = `-- name: GetUserById :one
SELECT id, email, password, full_name, verified_email, avatar_url, bio, open_to_work, created_at, updated_at, deleted_at FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.VerifiedEmail,
		&i.AvatarUrl,
		&i.Bio,
		&i.OpenToWork,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listPopularPosts = `-- name: ListPopularPosts :many
SELECT id, user_id, content, image_url, like_count, comment_count, repost_count, repost, original_post_id, created_at, updated_at, COUNT(id) OVER () AS total_rows
FROM posts
ORDER BY 
	like_count DESC,
	repost_count DESC,
	comment_count DESC,
	updated_at DESC
OFFSET $1
LIMIT $2
`

type ListPopularPostsParams struct {
	Offset int32
	Limit  int32
}

type ListPopularPostsRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
}

func (q *Queries) ListPopularPosts(ctx context.Context, arg ListPopularPostsParams) ([]ListPopularPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPopularPosts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPopularPostsRow
	for rows.Next() {
		var i ListPopularPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT id, user_id, content, image_url, like_count, comment_count, repost_count, repost, original_post_id, created_at, updated_at, COUNT(id) OVER () AS total_rows FROM posts 
ORDER BY updated_at DESC
OFFSET $1
LIMIT $2
`

type ListPostsParams struct {
	Offset int32
	Limit  int32
}

type ListPostsRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsRow
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByFollowing = `-- name: ListPostsByFollowing :many
SELECT p.id, p.user_id, p.content, p.image_url, p.like_count, p.comment_count, p.repost_count, p.repost, p.original_post_id, p.created_at, p.updated_at, COUNT(p.id) OVER () AS total_rows
FROM posts p
LEFT JOIN followings f ON p.user_id = f.follow_user_id
WHERE f.user_id = $1
ORDER BY p.updated_at DESC
OFFSET $2
LIMIT $3
`

type ListPostsByFollowingParams struct {
	UserID sql.NullInt64
	Offset int32
	Limit  int32
}

type ListPostsByFollowingRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
}

func (q *Queries) ListPostsByFollowing(ctx context.Context, arg ListPostsByFollowingParams) ([]ListPostsByFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByFollowing, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByFollowingRow
	for rows.Next() {
		var i ListPostsByFollowingRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
