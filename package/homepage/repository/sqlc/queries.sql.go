// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package homepage

import (
	"context"
	"database/sql"
)

const getFollowsRecommendationForUserId = `-- name: GetFollowsRecommendationForUserId :many
SELECT u.id, u.full_name, u.avatar_url, u.bio, u.open_to_work, 
    COUNT(u.id) OVER () AS total_rows
FROM users u
JOIN (
    SELECT DISTINCT f.follow_user_id
    FROM followings f
    JOIN followings f2 ON f.user_id = f2.follow_user_id
    WHERE f2.user_id = $1
) as users_reccomendation ON u.id = users_reccomendation.follow_user_id
WHERE u.id != $1
ORDER BY u.followers_count DESC
OFFSET $2
LIMIT $3
`

type GetFollowsRecommendationForUserIdParams struct {
	UserID sql.NullInt64
	Offset int32
	Limit  int32
}

type GetFollowsRecommendationForUserIdRow struct {
	ID         int64
	FullName   string
	AvatarUrl  sql.NullString
	Bio        sql.NullString
	OpenToWork sql.NullBool
	TotalRows  int64
}

func (q *Queries) GetFollowsRecommendationForUserId(ctx context.Context, arg GetFollowsRecommendationForUserIdParams) ([]GetFollowsRecommendationForUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowsRecommendationForUserId, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowsRecommendationForUserIdRow
	for rows.Next() {
		var i GetFollowsRecommendationForUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.AvatarUrl,
			&i.Bio,
			&i.OpenToWork,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, password, full_name, verified_email, avatar_url, bio, open_to_work, created_at, updated_at, deleted_at, followers_count, followings_count FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.FullName,
		&i.VerifiedEmail,
		&i.AvatarUrl,
		&i.Bio,
		&i.OpenToWork,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.FollowersCount,
		&i.FollowingsCount,
	)
	return i, err
}

const listPopularPosts = `-- name: ListPopularPosts :many
SELECT p.id, p.user_id, p.content, p.image_url, p.like_count, p.comment_count, p.repost_count, p.repost, p.original_post_id, p.created_at, p.updated_at, COUNT(p.id) OVER () AS total_rows,
       CASE
           WHEN p.created_at >= NOW() - INTERVAL '30 days' THEN true
           ELSE false
       END AS recent_post
FROM posts p
LEFT JOIN reported_posts rp ON p.id = rp.post_id AND rp.user_id = $1
WHERE rp.post_id IS NULL
ORDER BY
    recent_post DESC,
    (p.like_count + p.comment_count + p.repost_count) DESC
OFFSET $2
LIMIT $3
`

type ListPopularPostsParams struct {
	UserID sql.NullInt64
	Offset int32
	Limit  int32
}

type ListPopularPostsRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
	RecentPost     bool
}

func (q *Queries) ListPopularPosts(ctx context.Context, arg ListPopularPostsParams) ([]ListPopularPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPopularPosts, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPopularPostsRow
	for rows.Next() {
		var i ListPopularPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
			&i.RecentPost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT p.id, p.user_id, p.content, p.image_url, p.like_count, p.comment_count, p.repost_count, p.repost, p.original_post_id, p.created_at, p.updated_at, COUNT(p.id) OVER () AS total_rows 
FROM posts p
LEFT JOIN reported_posts rp ON p.id = rp.post_id AND rp.user_id = $1
WHERE rp.post_id IS NULL
ORDER BY updated_at DESC
OFFSET $2
LIMIT $3
`

type ListPostsParams struct {
	UserID sql.NullInt64
	Offset int32
	Limit  int32
}

type ListPostsRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsRow
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByFollowing = `-- name: ListPostsByFollowing :many
SELECT p.id, p.user_id, p.content, p.image_url, p.like_count, p.comment_count, p.repost_count, p.repost, p.original_post_id, p.created_at, p.updated_at, COUNT(p.id) OVER () AS total_rows
FROM posts p
LEFT JOIN reported_posts rp ON p.id = rp.post_id AND rp.user_id = $1
LEFT JOIN followings f ON p.user_id = f.follow_user_id
WHERE f.user_id = $1 AND rp.post_id IS NULL
ORDER BY p.updated_at DESC
OFFSET $2
LIMIT $3
`

type ListPostsByFollowingParams struct {
	UserID sql.NullInt64
	Offset int32
	Limit  int32
}

type ListPostsByFollowingRow struct {
	ID             int64
	UserID         sql.NullInt64
	Content        sql.NullString
	ImageUrl       sql.NullString
	LikeCount      sql.NullInt32
	CommentCount   sql.NullInt32
	RepostCount    sql.NullInt32
	Repost         sql.NullBool
	OriginalPostID sql.NullInt64
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	TotalRows      int64
}

func (q *Queries) ListPostsByFollowing(ctx context.Context, arg ListPostsByFollowingParams) ([]ListPostsByFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByFollowing, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByFollowingRow
	for rows.Next() {
		var i ListPostsByFollowingRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.ImageUrl,
			&i.LikeCount,
			&i.CommentCount,
			&i.RepostCount,
			&i.Repost,
			&i.OriginalPostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
